name: Update payout targets data

on:
  schedule:
    - cron: '*/30 * * * *'
  workflow_dispatch:

permissions:
  contents: write   # allow git push

concurrency:
  group: update-targets
  cancel-in-progress: true

jobs:
  update-targets:
    runs-on: ubuntu-latest
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git + pull latest
        env:
          GIT_USER_NAME: ${{ secrets.GIT_USER_NAME }}
          GIT_USER_EMAIL: ${{ secrets.GIT_USER_EMAIL }}
        run: |
          git config --global user.name "${GIT_USER_NAME:-automation-bot}"
          git config --global user.email "${GIT_USER_EMAIL:-bot@example.com}"
          # ensure we’re current
          git checkout main
          git pull --rebase origin main

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Clone bounty-targets-data
        run: |
          git clone --depth 1 https://github.com/arkadiyt/bounty-targets-data.git bounty-targets-data

      - name: Extract assets + wildcards (normalized)
        run: |
          set -euo pipefail
          mkdir -p data

          norm() {
            # lowercase, strip scheme, trim spaces, remove trailing slash and trailing dot
            sed 's#^[[:space:]]*##; s#[[:space:]]*$##' \
            | tr '[:upper:]' '[:lower:]' \
            | sed 's#^https\?://##' \
            | sed 's#/$##' \
            | sed 's#\.$##'
          }

          # Bugcrowd
          jq -r '.[] | select(.max_payout > 0) | .targets.in_scope[].target' bounty-targets-data/data/bugcrowd_data.json \
            | grep -vF "*." | norm > data/bugcrowd.txt
          jq -r '.[] | select(.max_payout > 0) | .targets.in_scope[].target' bounty-targets-data/data/bugcrowd_data.json \
            | grep -F "*." | norm > data/bugcrowd_wildcards.txt

          # HackerOne
          jq -r '.[] | select(.offers_bounties == true) | .targets.in_scope[].asset_identifier' bounty-targets-data/data/hackerone_data.json \
            | grep -vF "*." | norm > data/hackerone.txt
          jq -r '.[] | select(.offers_bounties == true) | .targets.in_scope[].asset_identifier' bounty-targets-data/data/hackerone_data.json \
            | grep -F "*." | norm > data/hackerone_wildcards.txt

          # HackenProof
          jq -r '.[] | .targets.in_scope[] | select(.reward == "Bounty") | .target' bounty-targets-data/data/hackenproof_data.json \
            | grep -vF "*." | norm > data/hackenproof.txt
          jq -r '.[] | .targets.in_scope[] | select(.reward == "Bounty") | .target' bounty-targets-data/data/hackenproof_data.json \
            | grep -F "*." | norm > data/hackenproof_wildcards.txt

          # Intigriti
          jq -r '.[] | select(.max_bounty.value > 0) | .targets.in_scope[]
            | select(.impact != "Out of scope" and .impact != "No bounty") | .endpoint' \
            bounty-targets-data/data/intigriti_data.json \
            | grep -vF "*." | norm > data/intigriti.txt
          jq -r '.[] | select(.max_bounty.value > 0) | .targets.in_scope[]
            | select(.impact != "Out of scope" and .impact != "No bounty") | .endpoint' \
            bounty-targets-data/data/intigriti_data.json \
            | grep -F "*." | norm > data/intigriti_wildcards.txt

      - name: Build consolidated lists + diff
        run: |
          set -euo pipefail
          # consolidate
          cat data/*_wildcards.txt 2>/dev/null | sort -u > wildcards.new || true
          cat data/*.txt data/*_wildcards.txt 2>/dev/null | sort -u > assets.new || true

          # ensure baseline files exist (LF endings)
          : > assets.out
          : > wildcards.out
          if [ ! -s assets.out ]; then echo -n > assets.out; fi
          if [ ! -s wildcards.out ]; then echo -n > wildcards.out; fi

          # normalize endings just in case
          awk '{sub(/\r$/,""); print}' assets.out > .assets.out && mv .assets.out assets.out
          awk '{sub(/\r$/,""); print}' wildcards.out > .wildcards.out && mv .wildcards.out wildcards.out

          # compute new additions vs repo-tracked lists
          grep -Fxvf assets.out assets.new > new_added_assets.tmp || true
          grep -Fxvf wildcards.out wildcards.new > new_added_wildcards.tmp || true

          # update tracked lists
          mv assets.new assets.out
          mv wildcards.new wildcards.out

      - name: Filter out already-notified and finalize outputs
        run: |
          set -euo pipefail
          # logs to remember what we’ve already sent to Telegram
          : > notified_assets.log
          : > notified_wildcards.log
          # if logs exist in repo, keep them
          [ -f notified_assets.log ] || touch notified_assets.log
          [ -f notified_wildcards.log ] || touch notified_wildcards.log

          # filter “newly added” against already-notified logs
          grep -Fxvf notified_assets.log new_added_assets.tmp > new_added_assets.out || true
          grep -Fxvf notified_wildcards.log new_added_wildcards.tmp > new_added_wildcards.out || true

          # append to logs (only the truly new lines)
          cat new_added_assets.out >> notified_assets.log || true
          cat new_added_wildcards.out >> notified_wildcards.log || true

      - name: Commit and push updated files
        run: |
          set -euo pipefail
          git add data/ assets.out wildcards.out notified_assets.log notified_wildcards.log \
                  new_added_assets.out new_added_wildcards.out
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          timestamp=$(TZ='Etc/GMT-3' date)
          git commit -m "Automated update ${timestamp} UTC+3"
          git push origin HEAD:main

      - name: Send Telegram notifications for new entries
        if: env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
        run: |
          set -euo pipefail
          send_msg() {
            local text="$1"
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" \
              -d text="$text" \
              -d parse_mode="Markdown" >/dev/null
          }

          if [ -s new_added_assets.out ]; then
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              text="New Payout Public Programs Asset Detected: ${line}  [bounty-targets-data](https://github.com/search?q=repo%3Aarkadiyt%2Fbounty-targets-data+%22${line}%22&type=code)   [Firebounty](https://firebounty.com/?sort=created_at&order=desc&search_field=scopes&search=${line})"
              send_msg "$text"
            done < new_added_assets.out
          fi

          if [ -s new_added_wildcards.out ]; then
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              text="New Payout Public Programs Wildcard Domain Detected: ${line}  [bounty-targets-data](https://github.com/search?q=repo%3Aarkadiyt%2Fbounty-targets-data+%22${line}%22&type=code)   [Firebounty](https://firebounty.com/?sort=created_at&order=desc&search_field=scopes&search=${line})"
              send_msg "$text"
            done < new_added_wildcards.out
          fi
