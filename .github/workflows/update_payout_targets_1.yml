name: Update payout targets data

on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: update-targets
  cancel-in-progress: true

jobs:
  update-targets:
    runs-on: ubuntu-latest
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Set Git identity
        run: |
          git config --global user.name  "${{ secrets.GIT_USER_NAME || 'automation-bot' }}"
          git config --global user.email "${{ secrets.GIT_USER_EMAIL || 'bot@example.com' }}"

      # === Option 1: use checkout to fetch the data repo fast ===
      - name: Fetch bounty-targets-data (fast)
        uses: actions/checkout@v4
        with:
          repository: arkadiyt/bounty-targets-data
          ref: main
          path: bounty-targets-data
          fetch-depth: 1
          persist-credentials: false
        timeout-minutes: 2

      - name: Extract payout targets (same logic as cron script)
        run: |
          set -e
          MAIN_DIR=$(pwd)
          bounty_targets_data_folder="$MAIN_DIR/bounty-targets-data"

          mkdir -p data
          cd data

          # Non-wildcards
          cat "$bounty_targets_data_folder/data/bugcrowd_data.json"    | jq -r '.[] | select(.max_payout > 0) | .targets.in_scope[].target'                                              | grep -vF "*." > bugcrowd.txt            || : > bugcrowd.txt
          cat "$bounty_targets_data_folder/data/hackerone_data.json"   | jq -r '.[] | select(.offers_bounties == true) | .targets.in_scope[].asset_identifier'                             | grep -vF "*." > hackerone.txt           || : > hackerone.txt
          cat "$bounty_targets_data_folder/data/hackenproof_data.json" | jq -r '.[] | .targets.in_scope[] | select(.reward == "Bounty") | .target'                                      | grep -vF "*." > hackenproof.txt         || : > hackenproof.txt
          cat "$bounty_targets_data_folder/data/intigriti_data.json"   | jq -r '.[] | select(.max_bounty.value > 0) | .targets.in_scope[] | select(.impact != "Out of scope" and .impact != "No bounty") | .endpoint' | grep -vF "*." > intigriti.txt || : > intigriti.txt
          cat "$bounty_targets_data_folder/data/yeswehack_data.json"   | jq -r '.[] | select(.max_bounty != null) | .targets.in_scope[].target'                                            | grep -vF "*." > yeswehack.txt           || : > yeswehack.txt

          # Wildcards only (strip http/https)
          cat "$bounty_targets_data_folder/data/bugcrowd_data.json"    | jq -r '.[] | select(.max_payout > 0) | .targets.in_scope[].target'                                              | grep -F "*." | sed 's#http://##;s#https://##' > bugcrowd_wildcards.txt    || : > bugcrowd_wildcards.txt
          cat "$bounty_targets_data_folder/data/hackerone_data.json"   | jq -r '.[] | select(.offers_bounties == true) | .targets.in_scope[].asset_identifier'                             | grep -F "*." | sed 's#http://##;s#https://##' > hackerone_wildcards.txt   || : > hackerone_wildcards.txt
          cat "$bounty_targets_data_folder/data/hackenproof_data.json" | jq -r '.[] | .targets.in_scope[] | select(.reward == "Bounty") | .target'                                      | grep -F "*." | sed 's#http://##;s#https://##' > hackenproof_wildcards.txt || : > hackenproof_wildcards.txt
          cat "$bounty_targets_data_folder/data/intigriti_data.json"   | jq -r '.[] | select(.max_bounty.value > 0) | .targets.in_scope[] | select(.impact != "Out of scope" and .impact != "No bounty") | .endpoint' | grep -F "*." | sed 's#http://##;s#https://##' > intigriti_wildcards.txt || : > intigriti_wildcards.txt
          cat "$bounty_targets_data_folder/data/yeswehack_data.json"   | jq -r '.[] | select(.max_bounty != null) | .targets.in_scope[].target'                                            | grep -F "*." | sed 's#http://##;s#https://##' > yeswehack_wildcards.txt   || : > yeswehack_wildcards.txt

          cd "$MAIN_DIR"

      - name: Consolidate to assets.out and wildcards.out
        run: |
          set -e
          cat data/*_wildcards.txt > wildcards.out || :
          sort -u wildcards.out -o wildcards.out || :

          cat data/* > assets.out || :
          sort -u assets.out -o assets.out || :

      - name: Diff with previous and produce new_added files
        run: |
          set -e
          NEW_ASSETS_FILE="new_added_assets.out"
          NEW_WILDCARD_FILE="new_added_wildcards.out"
          PREV_SCAN_FILE=".previous_assets"
          PREV_WILDCARD_FILE=".previous_wildcards"

          # old logic assets
          # if [ -f "$PREV_SCAN_FILE" ]; then
          #   grep -Fxvf "$PREV_SCAN_FILE" "assets.out" > "$NEW_ASSETS_FILE" || :
          #   cp "assets.out" "$PREV_SCAN_FILE"
          # else
          #   cp "assets.out" "$PREV_SCAN_FILE"
          #   : > "$NEW_ASSETS_FILE"
          # fi
          # Logic now
          if [ -f "$PREV_SCAN_FILE" ]; then
            grep -Fxvf "$PREV_SCAN_FILE" "assets.out" > "$NEW_ASSETS_FILE" || :
            cat "assets.out" >> "$PREV_SCAN_FILE"
            sort -u $PREV_SCAN_FILE -o $PREV_SCAN_FILE
          else
            cp "assets.out" "$PREV_SCAN_FILE"
            : > "$NEW_ASSETS_FILE"
          fi
          # old logic wildcards
          # if [ -f "$PREV_WILDCARD_FILE" ]; then
          #   grep -Fxvf "$PREV_WILDCARD_FILE" "wildcards.out" > "$NEW_WILDCARD_FILE" || :
          #   cp "wildcards.out" "$PREV_WILDCARD_FILE"
          # else
          #   cp "wildcards.out" "$PREV_WILDCARD_FILE"
          #   : > "$NEW_WILDCARD_FILE"
          # fi
          # New logic wildcards
          if [ -f "$PREV_WILDCARD_FILE" ]; then
            grep -Fxvf "$PREV_WILDCARD_FILE" "wildcards.out" > "$NEW_WILDCARD_FILE" || :
            cat "wildcards.out" >> "$PREV_WILDCARD_FILE"
            sort -u $PREV_WILDCARD_FILE -o $PREV_WILDCARD_FILE
          else
            cp "wildcards.out" "$PREV_WILDCARD_FILE"
            : > "$NEW_WILDCARD_FILE"
          fi
      - name: Notify via Telegram (assets only â€” matches your script)
        if: env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
        run: |
          set -e
          if [ -s new_added_assets.out ]; then
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              text="New Payout Public Programs Assets Detected: ${line}  [bounty-targets-data](https://github.com/search?q=repo%3Aarkadiyt%2Fbounty-targets-data+%22${line}%22&type=code)   [Firebounty](https://firebounty.com/?sort=created_at&order=desc&search_field=scopes&search=${line})"
              curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                -d chat_id="${TELEGRAM_CHAT_ID}" \
                -d text="$text" \
                -d parse_mode="Markdown" > /dev/null
            done < new_added_assets.out
          fi

          # NOTE: Your cron script has wildcard notification commented out.
          # If you later want it, uncomment below to match your message format.
          # if [ -s new_added_wildcards.out ]; then
          #   while IFS= read -r line; do
          #     [ -z "$line" ] && continue
          #     text="New Payout Public Programs Wildcard Domains Detected: ${line}  [bounty-targets-data](https://github.com/search?q=repo%3Aarkadiyt%2Fbounty-targets-data+%22${line}%22&type=code)   [Firebounty](https://firebounty.com/?sort=created_at&order=desc&search_field=scopes&search=${line})"
          #     curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
          #       -d chat_id="${TELEGRAM_CHAT_ID}" \
          #       -d text="$text" \
          #       -d parse_mode="Markdown" > /dev/null
          #   done < new_added_wildcards.out
          # fi

      - name: Commit and push outputs (same files as script)
        run: |
          set -e
          git add data/ wildcards.out assets.out new_added_assets.out new_added_wildcards.out .previous_assets .previous_wildcards
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          timestamp=$(TZ='Etc/GMT-3' date)
          git commit -m "Automated commit ${timestamp} UTC+3"
          git push origin HEAD:main
